<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Cubemap → Equirectangular (2:1) en navegador</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: system-ui, sans-serif; background: #0e0e10; color: #eaeaea; }
    header { padding: 16px 20px; border-bottom: 1px solid #222; }
    h1 { margin: 0 0 6px; font-size: 20px; }
    small { color: #aaa; }
    main { padding: 16px 20px; display: grid; gap: 16px; grid-template-columns: 1fr; }
    .panel { background: #141417; border: 1px solid #222; border-radius: 8px; padding: 14px; }
    .grid { display: grid; gap: 10px; grid-template-columns: repeat(3, minmax(0, 1fr)); }
    label { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
    input[type="file"] { padding: 8px; background: #1a1a1f; border: 1px solid #333; border-radius: 6px; color: #cfcfcf; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; align-items: center; }
    button { background: #2b6ef3; border: none; color: white; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    button.secondary { background: #30343a; color: #eaeaea; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { font-size: 13px; color: #9fb3ff; min-height: 18px; }
    footer { padding: 16px 20px; color: #888; border-top: 1px solid #222; font-size: 12px; }
    .note { color: #a7a7a7; font-size: 12px; }
    #viewer { width: 100%; height: 420px; background: #000; border-radius: 8px; }
  </style>
</head>
<body>
  <header>
    <h1>Cubemap → Equirectangular (2:1)</h1>
    <small>Procesamiento local en el navegador. Compatible con Three.js r105.</small>
  </header>

  <main>
    <section class="panel">
      <h2 style="margin:0 0 10px;font-size:16px;">Subí las 6 caras del cubo</h2>
      <div class="grid">
        <label><span>Right (+X)</span><input type="file" id="px" accept="image/*" /></label>
        <label><span>Left (-X)</span><input type="file" id="nx" accept="image/*" /></label>
        <label><span>Top (+Y)</span><input type="file" id="py" accept="image/*" /></label>
        <label><span>Bottom (-Y)</span><input type="file" id="ny" accept="image/*" /></label>
        <label><span>Front (+Z)</span><input type="file" id="pz" accept="image/*" /></label>
        <label><span>Back (-Z)</span><input type="file" id="nz" accept="image/*" /></label>
      </div>

      <div class="actions">
        <button id="build">Generar cubemap y visor</button>
        <button id="download" disabled>Descargar PNG 4096×2048</button>
        <span class="status" id="status"></span>
      </div>
      <p class="note">Orden requerido por CubeTextureLoader: [px, nx, py, ny, pz, nz].</p>
    </section>

    <section class="panel">
      <h2 style="margin:0 0 10px;font-size:16px;">Vista inmersiva</h2>
      <div id="viewer"></div>
    </section>
  </main>

  <footer>
    Equirectangular: proporción 2:1 (ancho = 2 × alto). El shader mapea latitud/longitud a un vector de dirección y muestrea el cubemap.
  </footer>

  <!-- Librerías -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.105.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/panolens/build/panolens.min.js"></script>

  <script>
    // Utilidad para leer archivos a DataURL
    const readAsDataURL = (file) => new Promise((resolve, reject) => {
      if (!file) return reject(new Error("Archivo faltante"));
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.onerror = () => reject(new Error("Error al leer archivo"));
      reader.readAsDataURL(file);
    });

    const statusEl = document.getElementById("status");
    const setStatus = (msg) => { statusEl.textContent = msg || ""; };

    // Render offscreen para equirectangular
    const previewCanvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas: previewCanvas, preserveDrawingBuffer: true, antialias: true });
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    // Fullscreen quad + shader equirectangular
    const quadGeometry = new THREE.PlaneBufferGeometry(2, 2);
    const equirectShader = {
      uniforms: {
        tCube: { value: null },
        flipEnvMap: { value: -1.0 } // cambiar a +1.0 si ves espejo horizontal
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform samplerCube tCube;
        uniform float flipEnvMap;
        void main() {
          float PI = 3.141592653589793;
          float lon = (vUv.x * 2.0 - 1.0) * PI;  // -PI .. PI
          float lat = (0.5 - vUv.y) * PI;        // -PI/2 .. PI/2
          float x = cos(lat) * sin(lon);
          float y = sin(lat);
          float z = cos(lat) * cos(lon);
          vec3 dir = normalize(vec3(x, y, z));
          dir.x *= flipEnvMap;
          gl_FragColor = textureCube(tCube, dir);
        }
      `
    };
    const quadMaterial = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(equirectShader.uniforms),
      vertexShader: equirectShader.vertexShader,
      fragmentShader: equirectShader.fragmentShader
    });
    const quad = new THREE.Mesh(quadGeometry, quadMaterial);
    scene.add(quad);

    // RenderTarget para exportar alta resolución
    const targetWidth = 4096;
    const targetHeight = 2048;
    const renderTarget = new THREE.WebGLRenderTarget(targetWidth, targetHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });

    // Visor Panolens (instancia única)
    const viewer = new PANOLENS.Viewer({
      container: document.getElementById("viewer"),
      autoHideInfospot: true
    });
    let currentPanorama = null;

    // Generación completa: cubemap → equirectangular → visor
    document.getElementById("build").onclick = async () => {
      try {
        setStatus("Verificando archivos…");
        const ids = ["px","nx","py","ny","pz","nz"];
        for (const id of ids) {
          if (!document.getElementById(id).files[0]) {
            setStatus("Falta subir: " + id.toUpperCase());
            return;
          }
        }

        setStatus("Leyendo imágenes…");
        const urls = [
          await readAsDataURL(document.getElementById("px").files[0]), // +X
          await readAsDataURL(document.getElementById("nx").files[0]), // -X
          await readAsDataURL(document.getElementById("py").files[0]), // +Y
          await readAsDataURL(document.getElementById("ny").files[0]), // -Y
          await readAsDataURL(document.getElementById("pz").files[0]), // +Z
          await readAsDataURL(document.getElementById("nz").files[0])  // -Z
        ];

        setStatus("Cargando cubemap…");
        const loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin("anonymous");
        const cubeTexture = loader.load(urls, () => {
          setStatus("Cubemap listo ✅");
          quadMaterial.uniforms.tCube.value = cubeTexture;

          // Render equirectangular (preview 2048×1024) y DataURL
          const w = 2048, h = 1024;
          renderer.setSize(w, h, false);
          renderer.setViewport(0, 0, w, h);
          renderer.setRenderTarget(null);
          renderer.render(scene, camera);
          const dataURL = renderer.domElement.toDataURL("image/png");

          // Actualizar visor inmersivo
          if (currentPanorama) {
            viewer.remove(currentPanorama);
            currentPanorama.dispose && currentPanorama.dispose();
            currentPanorama = null;
          }
          currentPanorama = new PANOLENS.ImagePanorama(dataURL);
          viewer.add(currentPanorama);

          // Habilitar descarga
          document.getElementById("download").disabled = false;
          setStatus("Visor listo ✅ Navegá con el mouse.");
        }, undefined, (err) => {
          console.error(err);
          setStatus("Error al cargar el cubemap");
        });
      } catch (e) {
        console.error(e);
        setStatus("Error: " + (e.message || "al procesar las imágenes"));
      }
    };

    // Descarga en 4096×2048
    document.getElementById("download").onclick = () => {
      try {
        // Render offscreen al target de alta resolución
        renderer.setSize(targetWidth, targetHeight, false);
        renderer.setViewport(0, 0, targetWidth, targetHeight);
        renderer.setRenderTarget(renderTarget);
        renderer.clear();
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);

        // Blit del target al framebuffer para exportar
        const blitScene = new THREE.Scene();
        const blitCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const blitMaterial = new THREE.MeshBasicMaterial({ map: renderTarget.texture });
        const blitQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), blitMaterial);
        blitScene.add(blitQuad);

        renderer.setSize(targetWidth, targetHeight, false);
        renderer.setViewport(0, 0, targetWidth, targetHeight);
        renderer.render(blitScene, blitCamera);

        const a = document.createElement("a");
        a.download = "panorama_equirectangular_4096x2048.png";
        a.href = renderer.domElement.toDataURL("image/png");
        a.click();
        setStatus("PNG descargado ✅");
      } catch (e) {
        console.error(e);
        setStatus("No se pudo descargar: " + (e.message || "error desconocido"));
      }
    };
  </script>
</body>
</html>
